{"mappings":"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","sources":["node_modules/@amo-tm/wsc/src/core/deferred.ts","node_modules/@amo-tm/wsc/src/core/component/provider.ts","node_modules/@amo-tm/wsc/src/core/component/component-container.ts","node_modules/@amo-tm/wsc/src/core/logger.ts","node_modules/@amo-tm/wsc/src/app/internal.ts","node_modules/@amo-tm/wsc/src/core/component/component.ts","node_modules/@amo-tm/wsc/src/wsc-service.ts","node_modules/@amo-tm/wsc/src/core/component/remote-instance-loader.ts","node_modules/@amo-tm/wsc/src/register.ts","node_modules/@amo-tm/wsc/src/api/initializeWsc.ts","node_modules/@amo-tm/wsc/src/api/mountWsc.ts","node_modules/@amo-tm/wsc/src/api.ts","node_modules/@amo-tm/wsc/src/index.ts","src/app.js"],"sourcesContent":["export class Deferred<R> {\n  promise: Promise<R>;\n  reject: (value?: unknown) => void = () => {};\n  resolve: (value?: unknown) => void = () => {};\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve as (value?: unknown) => void;\n      this.reject = reject as (value?: unknown) => void;\n    });\n  }\n}\n","import { Deferred } from '../deferred';\n\nimport { InstantiationMode, Name, NameServiceMapping } from './types';\nimport { ComponentContainer } from './component-container';\nimport { Component } from './component';\n\nconst DEFAULT_INSTANCE_NAME = '[DEFAULT_INSTANCE_NAME]';\n\n/**\n * Provider for instance for service name T, e.g. 'wsc', 'wsc-connector-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nexport class Provider<T extends Name> {\n  private component: Component<T> | null = null;\n  private readonly instances: Map<string, NameServiceMapping[T]> = new Map();\n  private readonly instancesDeferred: Map<string, Deferred<NameServiceMapping[T]>> = new Map();\n\n  constructor(private readonly name: T, private readonly container: ComponentContainer) {}\n\n  get(): Promise<NameServiceMapping[T]> {\n    const normalizedIdentifier = this.normalizeInstanceIdentifier();\n\n    if (this.instances.has(normalizedIdentifier)) {\n      return Promise.resolve(this.instances.get(normalizedIdentifier)!);\n    }\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          void this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n          });\n        } catch (e) {\n          // when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      } else {\n        const deferred = new Deferred<NameServiceMapping[T]>();\n        this.instancesDeferred.set(normalizedIdentifier, deferred);\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier)!.promise;\n  }\n\n  /**\n   *\n   * @param options.optional If optional is false or not provided, the method throws an error when\n   * the service is not immediately available.\n   * If optional is true, the method returns null if the service is not immediately available.\n   */\n  getImmediate(options: { optional: true }): NameServiceMapping[T] | null;\n  getImmediate(options?: { optional?: false }): NameServiceMapping[T];\n  getImmediate(options?: { optional?: boolean }): NameServiceMapping[T] | null {\n    const normalizedIdentifier = this.normalizeInstanceIdentifier();\n    const optional = options?.optional ?? false;\n\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        const instanceOrInstancePromise = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier,\n        })!;\n        if (instanceOrInstancePromise instanceof Promise) {\n          if (optional) {\n            return null;\n          } else {\n            throw Error(`Service ${this.name} is not ready.`);\n          }\n        }\n        return instanceOrInstancePromise;\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available.`);\n      }\n    }\n  }\n\n  setComponent(component: Component<T>): void {\n    if (component.name !== this.name) {\n      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n    }\n\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n\n    this.component = component;\n\n    // return early without attempting to initialize the component\n    if (!this.shouldAutoInitialize()) {\n      return;\n    }\n\n    // if the service is eager, initialize the default instance\n    if (isComponentEager(component)) {\n      try {\n        void this.getOrInitializeService({ instanceIdentifier: DEFAULT_INSTANCE_NAME });\n      } catch (e) {\n        // when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n      }\n    }\n  }\n\n  isComponentSet(): boolean {\n    return this.component !== null;\n  }\n\n  isInitialized(identifier: string = DEFAULT_INSTANCE_NAME): boolean {\n    return this.instances.has(identifier);\n  }\n\n  private getOrInitializeService({\n    instanceIdentifier,\n    options = {},\n  }: {\n    instanceIdentifier: string;\n    options?: Record<string, unknown>;\n  }): NameServiceMapping[T] | Promise<NameServiceMapping[T]> | null {\n    let instance = this.instances.get(instanceIdentifier);\n    let instanceDeferred = this.instancesDeferred.get(instanceIdentifier);\n\n    if (this.component && !(instance || instanceDeferred)) {\n      const instanceOrInstancePromise = this.component.instanceFactory(this.container, {\n        options,\n      });\n      if (instanceOrInstancePromise instanceof Promise) {\n        instanceDeferred = instanceDeferred || new Deferred<NameServiceMapping[T]>();\n        this.instancesDeferred.set(instanceIdentifier, instanceDeferred);\n        instanceOrInstancePromise.then((instance) => {\n          const currentInstanceDeferred = this.instancesDeferred.get(instanceIdentifier);\n          if (!currentInstanceDeferred || currentInstanceDeferred !== instanceDeferred) {\n            return;\n          }\n          this.instances.set(instanceIdentifier, instance);\n          this.instancesDeferred.delete(instanceIdentifier);\n          currentInstanceDeferred.resolve(instance);\n        }, instanceDeferred.reject);\n      } else {\n        instance = instanceOrInstancePromise;\n        this.instances.set(instanceIdentifier, instance);\n      }\n    }\n\n    return instance || instanceDeferred?.promise || null;\n  }\n\n  private normalizeInstanceIdentifier(): string {\n    return DEFAULT_INSTANCE_NAME;\n  }\n\n  private shouldAutoInitialize(): boolean {\n    return Boolean(this.component);\n  }\n}\n\nfunction isComponentEager<T extends Name>(component: Component<T>): boolean {\n  return component.instantiationMode === InstantiationMode.EAGER;\n}\n","import { Provider } from './provider';\nimport { Component } from './component';\nimport { Name } from './types';\n\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `wsc`, `wsc-connector-internal`\n */\nexport class ComponentContainer {\n  private readonly providers = new Map<string, Provider<Name>>();\n\n  constructor(public readonly name: string) {}\n\n  /**\n   * @param component Component being added\n   * @description When a component with the same name has already been registered throw an exception\n   */\n  addComponent<T extends Name>(component: Component<T>): void {\n    const provider = this.getProvider(component.name);\n    if (provider.isComponentSet()) {\n      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n    }\n\n    provider.setComponent(component);\n  }\n\n  /**\n   * getProvider provides a type safe interface where it can only be called with a field name\n   * present in NameServiceMapping interface.\n   *\n   * Amo SDKs providing services should extend NameServiceMapping interface to register\n   * themselves.\n   */\n  getProvider<T extends Name>(name: T): Provider<T> {\n    if (this.providers.has(name)) {\n      return this.providers.get(name) as unknown as Provider<T>;\n    }\n\n    // create a Provider for a service that hasn't registered with Amo\n    const provider = new Provider<T>(name, this);\n    this.providers.set(name, provider as unknown as Provider<Name>);\n\n    return provider as Provider<T>;\n  }\n}\n","type LogLevelString = 'debug' | 'verbose' | 'info' | 'warn' | 'error' | 'silent';\n\n/**\n * A container for all of the Logger instances\n */\nconst instances: Logger[] = [];\n\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nexport enum LogLevel {\n  DEBUG,\n  VERBOSE,\n  INFO,\n  WARN,\n  ERROR,\n  SILENT,\n}\n\nconst levelStringToEnum: { [key in LogLevelString]: LogLevel } = {\n  debug: LogLevel.DEBUG,\n  verbose: LogLevel.VERBOSE,\n  info: LogLevel.INFO,\n  warn: LogLevel.WARN,\n  error: LogLevel.ERROR,\n  silent: LogLevel.SILENT,\n};\n\n/**\n * The default log level\n */\nconst defaultLogLevel: LogLevel = LogLevel.INFO;\n\ntype LogHandler = (loggerInstance: Logger, logType: LogLevel, ...args: unknown[]) => void;\n\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for amo, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n  [LogLevel.DEBUG]: 'log',\n  [LogLevel.VERBOSE]: 'log',\n  [LogLevel.INFO]: 'info',\n  [LogLevel.WARN]: 'warn',\n  [LogLevel.ERROR]: 'error',\n};\n\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler: LogHandler = (instance, logType, ...args): void => {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  const now = new Date().toISOString();\n  const method = ConsoleMethod[logType as keyof typeof ConsoleMethod];\n  if (method) {\n    console[method as 'log' | 'info' | 'warn' | 'error'](`[${now}]  ${instance.name}:`, ...args);\n  } else {\n    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n  }\n};\n\nexport class Logger {\n  /**\n   * Gives you an instance of a Logger to capture messages according to\n   * Amo's logging scheme.\n   *\n   * @param name The name that the logs will be associated with\n   */\n  constructor(public name: string) {\n    /**\n     * Capture the current instance for later use\n     */\n    instances.push(this);\n  }\n\n  /**\n   * The log level of the given Logger instance.\n   */\n  private _logLevel = defaultLogLevel;\n\n  get logLevel(): LogLevel {\n    return this._logLevel;\n  }\n\n  set logLevel(val: LogLevel) {\n    if (!(val in LogLevel)) {\n      throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n    }\n    this._logLevel = val;\n  }\n\n  // Workaround for setter/getter having to be the same type.\n  setLogLevel(val: LogLevel | LogLevelString): void {\n    this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n  }\n\n  /**\n   * The main (internal) log handler for the Logger instance.\n   * Can be set to a new function in internal package code but not by user.\n   */\n  private _logHandler: LogHandler = defaultLogHandler;\n  get logHandler(): LogHandler {\n    return this._logHandler;\n  }\n  set logHandler(val: LogHandler) {\n    if (typeof val !== 'function') {\n      throw new TypeError('Value assigned to `logHandler` must be a function');\n    }\n    this._logHandler = val;\n  }\n\n  /**\n   * The functions below are all based on the `console` interface\n   */\n\n  debug(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.DEBUG, ...args);\n  }\n  log(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.VERBOSE, ...args);\n  }\n  info(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.INFO, ...args);\n  }\n  warn(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.WARN, ...args);\n  }\n  error(...args: unknown[]): void {\n    this._logHandler(this, LogLevel.ERROR, ...args);\n  }\n}\n\nexport function setLogLevel(level: LogLevelString | LogLevel): void {\n  instances.forEach((instance) => {\n    instance.setLogLevel(level);\n  });\n}\n","import { Name } from '../core/component/types';\nimport { Component } from '../core/component/component';\nimport { Provider } from '../core/component/provider';\nimport { ComponentContainer } from '../core/component/component-container';\nimport { Logger } from '../core/logger';\nimport { _registerRemoteInstanceFactory } from '../core/component/remote-instance-loader';\n\n/**\n * The default container name\n *\n * @internal\n */\nconst DEFAULT_CONTAINER_NAME = '[DEFAULT_CONTAINER_NAME]';\n\nconst container = new ComponentContainer(DEFAULT_CONTAINER_NAME);\nconst logger = new Logger('app');\n\nwindow.AmoJsSdk = {\n  ...(window.AmoJsSdk || {}),\n  _registerInstanceFactory: _registerRemoteInstanceFactory,\n};\n\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const _components = new Map<string, Component<any>>();\n\n/**\n * @param component - the component being added to the default container\n * @internal\n */\nexport function _addComponent<T extends Name>(component: Component<T>): void {\n  try {\n    container.addComponent(component);\n  } catch (e) {\n    logger.debug(\n      `Component ${component.name} failed to register with ComponentContainer ${container.name}`,\n      e\n    );\n  }\n}\n\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nexport function _registerComponent<T extends Name>(component: Component<T>): boolean {\n  const componentName = component.name;\n  if (_components.has(componentName)) {\n    logger.debug(`There were multiple attempts to register component ${componentName}.`);\n\n    return false;\n  }\n\n  _components.set(componentName, component);\n\n  // add the component to existing container instances\n  _addComponent(component);\n\n  return true;\n}\n\n/**\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nexport function _getProvider<T extends Name>(name: T): Provider<T> {\n  return container.getProvider(name);\n}\n","import { InstantiationMode, InstanceFactory, Name } from './types';\n\n/**\n * Component for service name T, e.g. `wsc`\n */\nexport class Component<T extends Name = Name> {\n  instantiationMode = InstantiationMode.LAZY;\n\n  /**\n   *\n   * @param name The public service name, e.g. wsc, wsc-connector-internal\n   * @param instanceFactory Service factory responsible for creating the public interface\n   \n   */\n  constructor(readonly name: T, readonly instanceFactory: InstanceFactory<T>) {}\n\n  setInstantiationMode(mode: InstantiationMode): this {\n    this.instantiationMode = mode;\n    return this;\n  }\n}\n","import { Provider } from './core/component/provider';\nimport { Deferred } from './core/deferred';\nimport { WscParams } from './interfaces/public-types';\nimport { WscConnectorInnerName } from './interfaces/wsc-connector-inner';\n\nexport class WscService {\n  private currentWscParams: WscParams | null = null;\n  private iframeElementDeffered: Deferred<HTMLIFrameElement> | null = null;\n  private connectingPromise: Promise<void | Error> | null = null;\n\n  constructor(private readonly wscConnectorInnerProvider: Provider<WscConnectorInnerName>) {}\n\n  updateParams(wscParams: WscParams): void {\n    // Preload wscConnectorInner\n    void this.wscConnectorInnerProvider.get();\n\n    this.currentWscParams = wscParams;\n    this.connectingPromise = null;\n    this.iframeElementDeffered = null;\n  }\n\n  getCurrentWscParams(): WscParams | null {\n    return this.currentWscParams;\n  }\n\n  async connectIframe(wscParams: WscParams): Promise<void | Error> {\n    if (!this.connectingPromise) {\n      const connectingPromise = new Promise<void | Error>(async (resolve) => {\n        const [iframeElement, wscConnectorInner] = await Promise.all([\n          this.getIframeElement(),\n          this.wscConnectorInnerProvider.get(),\n        ]);\n        if (connectingPromise !== this.connectingPromise) {\n          return;\n        }\n        if (iframeElement instanceof Error) {\n          resolve(iframeElement);\n          return;\n        }\n        if (wscParams !== this.currentWscParams) {\n          resolve(new Error('The Wsc was reinitialized with other params.'));\n          return;\n        }\n        await wscConnectorInner.initializeIframe(iframeElement, wscParams);\n        if (connectingPromise !== this.connectingPromise) {\n          return;\n        }\n        resolve();\n      });\n      this.connectingPromise = connectingPromise;\n    }\n\n    return this.connectingPromise;\n  }\n\n  async getIframeElement(): Promise<HTMLIFrameElement | Error> {\n    if (!this.currentWscParams) {\n      return new Error('The Wsc should be initialized before.');\n    }\n    if (!this.iframeElementDeffered) {\n      const deffered = new Deferred<HTMLIFrameElement>();\n      this.iframeElementDeffered = deffered;\n      void this.wscConnectorInnerProvider\n        .get()\n        .then((wscConnectorInner) => {\n          return wscConnectorInner.createIframeElement();\n        })\n        .then((iframeElement) => {\n          if (deffered === this.iframeElementDeffered) {\n            deffered.resolve(iframeElement);\n          }\n        });\n    }\n    return this.iframeElementDeffered!.promise;\n  }\n}\n","import { Deferred } from '../deferred';\nimport { InstanceFactory, Name, RemoteInstanceUrl } from './types';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst instanceFactoriesDeferred = new Map<RemoteInstanceUrl, Deferred<InstanceFactory<any>>>();\n\nexport const _registerRemoteInstanceFactory = <T extends Name>(\n  instanceFactory: InstanceFactory<T>\n): void => {\n  const currentScript = document.currentScript;\n  if (!currentScript || !(currentScript instanceof HTMLScriptElement)) {\n    return;\n  }\n  const remoteInstanceUrl: RemoteInstanceUrl = currentScript.src;\n  const instanceFactoryDeferred = instanceFactoriesDeferred.get(remoteInstanceUrl);\n  if (!instanceFactoryDeferred) {\n    return;\n  }\n  instanceFactoryDeferred.resolve(instanceFactory);\n};\n\nexport class RemoteInstanceLoader<T extends Name> {\n  constructor(private readonly url: RemoteInstanceUrl) {}\n\n  getInstanceFactory(): InstanceFactory<T> {\n    return (container, options) => {\n      let instanceFactoryDeferred: Deferred<InstanceFactory<T>> | undefined =\n        instanceFactoriesDeferred.get(this.url);\n\n      if (!instanceFactoryDeferred) {\n        instanceFactoryDeferred = new Deferred<InstanceFactory<T>>();\n        instanceFactoriesDeferred.set(this.url, instanceFactoryDeferred);\n        this.initializeRemoteScript(this.url);\n      }\n\n      return instanceFactoryDeferred.promise.then((instanceFactory) => {\n        return instanceFactory(container, options);\n      });\n    };\n  }\n\n  private initializeRemoteScript(url: string): void {\n    const scriptElement = document.createElement('script');\n    scriptElement.type = 'text/javascript';\n    scriptElement.async = true;\n    scriptElement.src = url;\n\n    const anchorElement = document.getElementsByTagName('script')[0];\n    anchorElement.parentNode!.insertBefore(scriptElement, anchorElement);\n  }\n}\n","import { _registerComponent } from './app/internal';\nimport { Component } from './core/component/component';\nimport { InstanceFactory } from './core/component/types';\nimport { RemoteInstanceLoader } from './core/component/remote-instance-loader';\nimport { WscService } from './wsc-service';\nimport { WscConnectorInnerName } from './interfaces/wsc-connector-inner';\n\nconst WscFactory: InstanceFactory<'wsc'> = (container) => {\n  return new WscService(container.getProvider('wsc-connector-inner'));\n};\n\nexport function registerWsc(): void {\n  _registerComponent(\n    new Component(\n      'wsc-connector-inner',\n      new RemoteInstanceLoader<WscConnectorInnerName>(\n        'https://js.amo.tm/v1.3/wsc/connector.js'\n      ).getInstanceFactory()\n    )\n  );\n\n  _registerComponent(new Component('wsc', WscFactory));\n}\n","import { _getProvider } from '../app/internal';\nimport { WscParams } from '../interfaces/public-types';\n\nexport const initializeWsc = (wscParams: WscParams): void => {\n  const wsc = _getProvider('wsc').getImmediate();\n  wsc.updateParams(wscParams);\n};\n","import { _getProvider } from '../app/internal';\nimport { MountWscOptions } from '../interfaces/public-types';\n\nexport const mountWsc = async (options: MountWscOptions): Promise<void> => {\n  const wsc = _getProvider('wsc').getImmediate();\n\n  const wscParams = wsc.getCurrentWscParams();\n  if (!wscParams) {\n    if (options.onError) {\n      options.onError(new Error('The Wsc should be initialized before mount.'));\n    }\n    return;\n  }\n\n  let containerElement: HTMLElement | null = null;\n  if (options.container instanceof HTMLElement) {\n    containerElement = options.container;\n  } else {\n    containerElement = document.querySelector(options.container);\n  }\n\n  if (!containerElement) {\n    if (options.onError) {\n      options.onError(new Error('The container element is not found.'));\n    }\n    return;\n  }\n\n  const iframeElement = await wsc.getIframeElement();\n  const wscParamsAfterIframeElementGet = wsc.getCurrentWscParams();\n  if (wscParamsAfterIframeElementGet !== wscParams) {\n    return;\n  }\n  if (iframeElement instanceof Error) {\n    if (options.onError) {\n      options.onError(iframeElement);\n    }\n    return;\n  }\n\n  containerElement.innerHTML = '';\n  containerElement.append(iframeElement);\n\n  const connectIframeResult = await wsc.connectIframe(wscParams);\n  if (connectIframeResult instanceof Error) {\n    if (options.onError) {\n      options.onError(connectIframeResult);\n    }\n    return;\n  }\n  if (options.onSuccess) {\n    options.onSuccess();\n  }\n};\n","import { WscParams, MountWscOptions } from './interfaces/public-types';\nimport { initializeWsc as _initializeWsc } from './api/initializeWsc';\nimport { mountWsc as _mountWsc } from './api/mountWsc';\n\nexport const initializeWsc = (wscParams: WscParams): void => {\n  _initializeWsc(wscParams);\n};\n\nexport const mountWsc = (options: MountWscOptions): void => {\n  void _mountWsc(options);\n};\n","import { registerWsc } from './register';\nexport { initializeWsc, mountWsc } from './api';\nexport * from './interfaces/public-types';\n\nregisterWsc();\n","import { initializeWsc, mountWsc } from '@amo-tm/wsc';\n\ninitializeWsc(window.AMO_WSC_PARAMS);\nmountWsc({\n    container: \"#amo-subject-container\"\n});"],"names":["$5100780d8b835ef2$var$Deferred","this","reject","resolve","promise","Promise","$5100780d8b835ef2$var$Provider","name","container","component","instances","Map","instancesDeferred","normalizedIdentifier","normalizeInstanceIdentifier","has","get","isInitialized","shouldAutoInitialize","getOrInitializeService","e","deferred","set","options","_a","optional","Error","instanceOrInstancePromise","instanceIdentifier","instantiationMode","$5100780d8b835ef2$var$isComponentEager","isComponentSet","identifier","instance1","instanceDeferred","instanceFactory","then","instance","currentInstanceDeferred","delete","Boolean","LogLevel","verbose","$5100780d8b835ef2$var$LogLevel","VERBOSE","INFO","WARN","error","ERROR","SILENT","$5100780d8b835ef2$var$ConsoleMethod","DEBUG","$5100780d8b835ef2$var$defaultLogHandler","logType","args","logLevel","now","Date","toISOString","method","console","$5100780d8b835ef2$var$RemoteInstanceLoader","url","getInstanceFactory","instanceFactoryDeferred","$5100780d8b835ef2$var$instanceFactoriesDeferred","initializeRemoteScript","scriptElement","document","createElement","async","src","anchorElement","getElementsByTagName","parentNode","insertBefore","providers","addComponent","provider","getProvider","setComponent","$5100780d8b835ef2$var$logger","constructor","_logLevel","$5100780d8b835ef2$var$defaultLogLevel","_logHandler","val","TypeError","$5100780d8b835ef2$var$levelStringToEnum","logHandler","debug","info","warn","AmoJsSdk","Object","assign","currentScript","remoteInstanceUrl","$5100780d8b835ef2$var$_registerComponent","componentName","$5100780d8b835ef2$var$_components","$5100780d8b835ef2$var$container","$5100780d8b835ef2$var$_getProvider","$5100780d8b835ef2$var$Component","setInstantiationMode","mode","$5100780d8b835ef2$var$WscService","wscConnectorInnerProvider","currentWscParams","iframeElementDeffered","connectingPromise","updateParams","wscParams","_initializeWsc","iframeElement","wscConnectorInner","all","getIframeElement","_mountWsc","window","AMO_WSC_PARAMS"],"version":3,"file":"index.8a1ec708.js.map"}